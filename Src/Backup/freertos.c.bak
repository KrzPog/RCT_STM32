/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * File Name          : freertos.c
 * Description        : Code for freertos applications
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "FreeRTOS.h"
#include "task.h"
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */

#include "usbd_cdc_if.h"

#include "App/turretStates.h"
#include "ModbusRegisters/reg_input.h"
#include "ModbusRegisters/reg_holding.h"
#include "Sensors/encoders.h"
#include "Sensors/analog_sensors.h"
#include "Sensors/accelerometer.h"

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN Variables */

/* USER CODE END Variables */
/* Definitions for task_encodersUpdate */
osThreadId_t task_encodersUpdateHandle;
const osThreadAttr_t task_encodersUpdate_attributes = {
  .name = "task_encodersUpdate",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityAboveNormal,
};
/* Definitions for task_stateLampUpdate */
osThreadId_t task_stateLampUpdateHandle;
const osThreadAttr_t task_stateLampUpdate_attributes = {
  .name = "task_stateLampUpdate",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityNormal,
};
/* Definitions for task_pollModbus */
osThreadId_t task_pollModbusHandle;
const osThreadAttr_t task_pollModbus_attributes = {
  .name = "task_pollModbus",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityBelowNormal,
};
/* Definitions for task_checkIfTimeout */
osThreadId_t task_checkIfTimeoutHandle;
const osThreadAttr_t task_checkIfTimeout_attributes = {
  .name = "task_checkIfTimeout",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityLow,
};
/* Definitions for task_PIDCalculate_motor1 */
osThreadId_t task_PIDCalculate_motor1Handle;
const osThreadAttr_t task_PIDCalculate_motor1_attributes = {
  .name = "task_PIDCalculate_motor1",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityHigh,
};
/* Definitions for task_PIDCalculate_motor2 */
osThreadId_t task_PIDCalculate_motor2Handle;
const osThreadAttr_t task_PIDCalculate_motor2_attributes = {
  .name = "task_PIDCalculate_motor2",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityHigh,
};
/* Definitions for task_debugUSBPrint */
osThreadId_t task_debugUSBPrintHandle;
const osThreadAttr_t task_debugUSBPrint_attributes = {
  .name = "task_debugUSBPrint",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityLow,
};
/* Definitions for task_checkAccelValues */
osThreadId_t task_checkAccelValuesHandle;
const osThreadAttr_t task_checkAccelValues_attributes = {
  .name = "task_checkAccelValues",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityAboveNormal,
};
/* Definitions for task_checkAnalogSensorsData */
osThreadId_t task_checkAnalogSensorsDataHandle;
const osThreadAttr_t task_checkAnalogSensorsData_attributes = {
  .name = "task_checkAnalogSensorsData",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityAboveNormal,
};

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN FunctionPrototypes */

/* USER CODE END FunctionPrototypes */

void taskInit_encodersUpdate(void *argument);
void taskInit_stateLampUpdate(void *argument);
void taskInit_pollModbus(void *argument);
void taskInit_checkIfTimeout(void *argument);
void taskInit_PIDCalculate_motor1(void *argument);
void taskInit_PIDCalculate_motor2(void *argument);
void taskInit_debugUSBPrint(void *argument);
void taskInit_checkAccelValues(void *argument);
void taskInit_checkAnalogSensorsData(void *argument);

extern void MX_USB_DEVICE_Init(void);
void MX_FREERTOS_Init(void); /* (MISRA C 2004 rule 8.1) */

/**
  * @brief  FreeRTOS initialization
  * @param  None
  * @retval None
  */
void MX_FREERTOS_Init(void) {
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* USER CODE BEGIN RTOS_MUTEX */
  /* add mutexes, ... */
  /* USER CODE END RTOS_MUTEX */

  /* USER CODE BEGIN RTOS_SEMAPHORES */
  /* add semaphores, ... */
  /* USER CODE END RTOS_SEMAPHORES */

  /* USER CODE BEGIN RTOS_TIMERS */
  /* start timers, add new ones, ... */
  /* USER CODE END RTOS_TIMERS */

  /* USER CODE BEGIN RTOS_QUEUES */
  /* add queues, ... */
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  /* creation of task_encodersUpdate */
  task_encodersUpdateHandle = osThreadNew(taskInit_encodersUpdate, NULL, &task_encodersUpdate_attributes);

  /* creation of task_stateLampUpdate */
  task_stateLampUpdateHandle = osThreadNew(taskInit_stateLampUpdate, NULL, &task_stateLampUpdate_attributes);

  /* creation of task_pollModbus */
  task_pollModbusHandle = osThreadNew(taskInit_pollModbus, NULL, &task_pollModbus_attributes);

  /* creation of task_checkIfTimeout */
  task_checkIfTimeoutHandle = osThreadNew(taskInit_checkIfTimeout, NULL, &task_checkIfTimeout_attributes);

  /* creation of task_PIDCalculate_motor1 */
  task_PIDCalculate_motor1Handle = osThreadNew(taskInit_PIDCalculate_motor1, NULL, &task_PIDCalculate_motor1_attributes);

  /* creation of task_PIDCalculate_motor2 */
  task_PIDCalculate_motor2Handle = osThreadNew(taskInit_PIDCalculate_motor2, NULL, &task_PIDCalculate_motor2_attributes);

  /* creation of task_debugUSBPrint */
  task_debugUSBPrintHandle = osThreadNew(taskInit_debugUSBPrint, NULL, &task_debugUSBPrint_attributes);

  /* creation of task_checkAccelValues */
  task_checkAccelValuesHandle = osThreadNew(taskInit_checkAccelValues, NULL, &task_checkAccelValues_attributes);

  /* creation of task_checkAnalogSensorsData */
  task_checkAnalogSensorsDataHandle = osThreadNew(taskInit_checkAnalogSensorsData, NULL, &task_checkAnalogSensorsData_attributes);

  /* USER CODE BEGIN RTOS_THREADS */
  /* add threads, ... */
  /* USER CODE END RTOS_THREADS */

  /* USER CODE BEGIN RTOS_EVENTS */
  /* add events, ... */
  /* USER CODE END RTOS_EVENTS */

}

/* USER CODE BEGIN Header_taskInit_encodersUpdate */
/**
 * @brief  Function implementing the task_encodersUpdate thread.
 * @param  argument: Not used
 * @retval None
 */
/* USER CODE END Header_taskInit_encodersUpdate */
void taskInit_encodersUpdate(void *argument)
{
  /* init code for USB_DEVICE */
  MX_USB_DEVICE_Init();
  /* USER CODE BEGIN taskInit_encodersUpdate */

  encodersInit();

  /* Infinite loop */
  for (;;)
  {
    if (encoderUpdate((Encoder *)&rot_motor_encoder))
      vTaskResume(task_PIDCalculate_motor1Handle);
    if (encoderUpdate((Encoder *)&elev_motor_encoder))
      vTaskResume(task_PIDCalculate_motor2Handle);
    osDelay(ENCODER_SAMPLING_TIME_MS / portTICK_RATE_MS);
  }
  /* USER CODE END taskInit_encodersUpdate */
}

/* USER CODE BEGIN Header_taskInit_stateLampUpdate */
/**
 * @brief Function implementing the task_stateLampUpdate thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_taskInit_stateLampUpdate */
void taskInit_stateLampUpdate(void *argument)
{
  /* USER CODE BEGIN taskInit_stateLampUpdate */
  /* Infinite loop */
  for (;;)
  {
    stateLampUpdate();
    osDelay(LAMP_SWITCHING_WHEN_FAULT_MS / portTICK_RATE_MS);
  }
  /* USER CODE END taskInit_stateLampUpdate */
}

/* USER CODE BEGIN Header_taskInit_pollModbus */
/**
 * @brief Function implementing the task_pollModbus thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_taskInit_pollModbus */
void taskInit_pollModbus(void *argument)
{
  /* USER CODE BEGIN taskInit_pollModbus */
  /* Infinite loop */
  for (;;)
  {
#if !(COMM_MODE & COMM_MODE_BIT_FRWD_USB_BT)
    eMBPoll();
#endif
    osDelay(1);
  }
  /* USER CODE END taskInit_pollModbus */
}

/* USER CODE BEGIN Header_taskInit_checkIfTimeout */
/**
 * @brief Function implementing the task_checkIfTimeout thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_taskInit_checkIfTimeout */
void taskInit_checkIfTimeout(void *argument)
{
  /* USER CODE BEGIN taskInit_checkIfTimeout */
  /* Infinite loop */
  for (;;)
  {
#if !(COMM_MODE & COMM_MODE_BIT_FRWD_USB_BT)
    checkIfCommTimeout();
#endif
    osDelay(500 / portTICK_RATE_MS);
  }
  /* USER CODE END taskInit_checkIfTimeout */
}

/* USER CODE BEGIN Header_taskInit_PIDCalculate_motor1 */
/**
 * @brief Function implementing the task_PIDCalculate_motor1 thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_taskInit_PIDCalculate_motor1 */
void taskInit_PIDCalculate_motor1(void *argument)
{
  /* USER CODE BEGIN taskInit_PIDCalculate_motor1 */
  /* Infinite loop */
  for (;;)
  {
    vTaskSuspend(NULL); //!< @todo implement PID calculation
  }
  /* USER CODE END taskInit_PIDCalculate_motor1 */
}

/* USER CODE BEGIN Header_taskInit_PIDCalculate_motor2 */
/**
 * @brief Function implementing the task_PIDCalculate_motor2 thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_taskInit_PIDCalculate_motor2 */
void taskInit_PIDCalculate_motor2(void *argument)
{
  /* USER CODE BEGIN taskInit_PIDCalculate_motor2 */
  /* Infinite loop */
  for (;;)
  {
    vTaskSuspend(NULL); //!< @todo implement PID calculation
  }
  /* USER CODE END taskInit_PIDCalculate_motor2 */
}

/* USER CODE BEGIN Header_taskInit_debugUSBPrint */
/**
 * @brief Function implementing the task_debugUSBPrint thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_taskInit_debugUSBPrint */
void taskInit_debugUSBPrint(void *argument)
{
  /* USER CODE BEGIN taskInit_debugUSBPrint */
  /* Infinite loop */
  for (;;)
  {
    //!< @note Purpose of this task is to print debug information to USB CDC
    // USR_Printf_USBD_CDC("Rot Pos: %5d, Rot Vel: %5d, Elev Pos: %5d, Elev Vel: %5d,\r\n",  rot_motor_encoder.Position.Raw.newVal, rot_motor_encoder.Speed.raw, elev_motor_encoder.Position.Raw.newVal, elev_motor_encoder.Speed.raw);
    // USR_Printf_USBD_CDC("Rot Pos: %5d, Rot Vel: %5d, Elev Pos: %5d, Elev Vel: %5d,\r\n",  (int16_t)regInput[regInpIx(REG_INPUT_ROT_POSITION)], (int16_t)regInput[regInpIx(REG_INPUT_ROT_SPEED)], (int16_t)regInput[regInpIx(REG_INPUT_ELEV_POSITION)], (int16_t)regInput[regInpIx(REG_INPUT_ELEV_SPEED)]);
    
    USR_Printf_USBD_CDC("Accel [X:%5d Y:%5d Z:%5d], Gyro [X:%5d Y:%5d Z:%5d],\r\n  Analog [1:%5d 2:%5d 3:%5d 4:%5d]\r\n", (int16_t)regInput[regInpIx(REG_ACCEL_X)], (int16_t)regInput[regInpIx(REG_ACCEL_Y)], (int16_t)regInput[regInpIx(REG_ACCEL_Z)], (int16_t)regInput[regInpIx(REG_GYRO_X)], (int16_t)regInput[regInpIx(REG_GYRO_Y)], (int16_t)regInput[regInpIx(REG_GYRO_Z)], (uint16_t)regInput[regInpIx(REG_INPUT_MAIN_VOLTAGE)], (uint16_t)regInput[regInpIx(REG_INPUT_MAIN_CURRENT)], (uint16_t)regInput[regInpIx(REG_INPUT_ROT_CURRENT)], (uint16_t)regInput[regInpIx(REG_INPUT_ELEV_CURRENT)]);

    osDelay(100 / portTICK_RATE_MS);

    osDelay(100 / portTICK_RATE_MS);
  }
  /* USER CODE END taskInit_debugUSBPrint */
}

/* USER CODE BEGIN Header_taskInit_checkAccelValues */
/**
 * @brief Function implementing the task_checkAccelValues thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_taskInit_checkAccelValues */
void taskInit_checkAccelValues(void *argument)
{
  /* USER CODE BEGIN taskInit_checkAccelValues */
  MPU6050_Init();
  /* Infinite loop */
  for (;;)
  {
    accelerometerUpdate();
    osDelay(DEBUG_USB_PRINT_MS / portTICK_RATE_MS);
  }
  /* USER CODE END taskInit_checkAccelValues */
}

/* USER CODE BEGIN Header_taskInit_checkAnalogSensorsData */
/**
 * @brief Function implementing the task_checkAnalogSensorsData thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_taskInit_checkAnalogSensorsData */
void taskInit_checkAnalogSensorsData(void *argument)
{
  /* USER CODE BEGIN taskInit_checkAnalogSensorsData */
  /* Infinite loop */
  for (;;)
  {
    analogSensorsUpdate();
    osDelay(DEBUG_USB_PRINT_MS / portTICK_RATE_MS);
  }
  /* USER CODE END taskInit_checkAnalogSensorsData */
}

/* Private application code --------------------------------------------------*/
/* USER CODE BEGIN Application */

/* USER CODE END Application */

